// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus as dbus;
use dbus::arg;
use dbus::blocking;

pub trait Manager {
    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error>;
    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error>;
    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error>;
    fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error>;
    fn release_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error>;
    fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn lock_sessions(&self) -> Result<(), dbus::Error>;
    fn unlock_sessions(&self) -> Result<(), dbus::Error>;
    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error>;
    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error>;
    fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error>;
    fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error>;
    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error>;
    fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn power_off(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn reboot(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn halt(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn suspend(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn can_power_off(&self) -> Result<String, dbus::Error>;
    fn can_reboot(&self) -> Result<String, dbus::Error>;
    fn can_halt(&self) -> Result<String, dbus::Error>;
    fn can_suspend(&self) -> Result<String, dbus::Error>;
    fn can_hibernate(&self) -> Result<String, dbus::Error>;
    fn can_hybrid_sleep(&self) -> Result<String, dbus::Error>;
    fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error>;
    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error>;
    fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error>;
    fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<arg::OwnedFd, dbus::Error>;
    fn can_reboot_parameter(&self) -> Result<String, dbus::Error>;
    fn set_reboot_parameter(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), dbus::Error>;
    fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_boot_loader_menu(&self, arg0: u64) -> Result<(), dbus::Error>;
    fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    fn set_reboot_to_boot_loader_entry(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn get_enable_wall_messages(&self) -> Result<bool, dbus::Error>;
    fn get_wall_message(&self) -> Result<String, dbus::Error>;
    fn get_nauto_vts(&self) -> Result<u32, dbus::Error>;
    fn get_kill_only_users(&self) -> Result<Vec<String>, dbus::Error>;
    fn get_kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error>;
    fn get_kill_user_processes(&self) -> Result<bool, dbus::Error>;
    fn get_reboot_parameter(&self) -> Result<String, dbus::Error>;
    fn get_reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error>;
    fn get_reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error>;
    fn get_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
    fn get_boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error>;
    fn get_idle_hint(&self) -> Result<bool, dbus::Error>;
    fn get_idle_since_hint(&self) -> Result<u64, dbus::Error>;
    fn get_idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error>;
    fn get_block_inhibited(&self) -> Result<String, dbus::Error>;
    fn get_delay_inhibited(&self) -> Result<String, dbus::Error>;
    fn get_inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error>;
    fn get_user_stop_delay_usec(&self) -> Result<u64, dbus::Error>;
    fn get_handle_power_key(&self) -> Result<String, dbus::Error>;
    fn get_handle_suspend_key(&self) -> Result<String, dbus::Error>;
    fn get_handle_hibernate_key(&self) -> Result<String, dbus::Error>;
    fn get_handle_lid_switch(&self) -> Result<String, dbus::Error>;
    fn get_handle_lid_switch_external_power(&self) -> Result<String, dbus::Error>;
    fn get_handle_lid_switch_docked(&self) -> Result<String, dbus::Error>;
    fn get_holdoff_timeout_usec(&self) -> Result<u64, dbus::Error>;
    fn get_idle_action(&self) -> Result<String, dbus::Error>;
    fn get_idle_action_usec(&self) -> Result<u64, dbus::Error>;
    fn get_preparing_for_shutdown(&self) -> Result<bool, dbus::Error>;
    fn get_preparing_for_sleep(&self) -> Result<bool, dbus::Error>;
    fn get_scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error>;
    fn get_docked(&self) -> Result<bool, dbus::Error>;
    fn get_lid_closed(&self) -> Result<bool, dbus::Error>;
    fn get_on_external_power(&self) -> Result<bool, dbus::Error>;
    fn get_remove_ipc(&self) -> Result<bool, dbus::Error>;
    fn get_runtime_directory_size(&self) -> Result<u64, dbus::Error>;
    fn get_inhibitors_max(&self) -> Result<u64, dbus::Error>;
    fn get_ncurrent_inhibitors(&self) -> Result<u64, dbus::Error>;
    fn get_sessions_max(&self) -> Result<u64, dbus::Error>;
    fn get_ncurrent_sessions(&self) -> Result<u64, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target=blocking::Connection>> Manager for blocking::Proxy<'a, C> {

    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSession", (arg0, ))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSessionByPID", (arg0, ))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetUser", (arg0, ))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetUserByPID", (arg0, ))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "GetSeat", (arg0, ))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListSessions", ())
            .and_then(|r: (Vec<(String, u32, String, String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListUsers", ())
            .and_then(|r: (Vec<(u32, String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListSeats", ())
            .and_then(|r: (Vec<(String, dbus::Path<'static>)>,)| Ok(r.0))
    }

    fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ListInhibitors", ())
            .and_then(|r: (Vec<(String, String, String, String, u32, u32)>,)| Ok(r.0))
    }

    fn release_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ReleaseSession", (arg0, ))
    }

    fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ActivateSession", (arg0, ))
    }

    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ActivateSessionOnSeat", (arg0, arg1, ))
    }

    fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "LockSession", (arg0, ))
    }

    fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "UnlockSession", (arg0, ))
    }

    fn lock_sessions(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "LockSessions", ())
    }

    fn unlock_sessions(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "UnlockSessions", ())
    }

    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "KillSession", (arg0, arg1, arg2, ))
    }

    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "KillUser", (arg0, arg1, ))
    }

    fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "TerminateSession", (arg0, ))
    }

    fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "TerminateUser", (arg0, ))
    }

    fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "TerminateSeat", (arg0, ))
    }

    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SetUserLinger", (arg0, arg1, arg2, ))
    }

    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "AttachDevice", (arg0, arg1, arg2, ))
    }

    fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "FlushDevices", (arg0, ))
    }

    fn power_off(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "PowerOff", (arg0, ))
    }

    fn reboot(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Reboot", (arg0, ))
    }

    fn halt(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Halt", (arg0, ))
    }

    fn suspend(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Suspend", (arg0, ))
    }

    fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Hibernate", (arg0, ))
    }

    fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "HybridSleep", (arg0, ))
    }

    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SuspendThenHibernate", (arg0, ))
    }

    fn can_power_off(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanPowerOff", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_reboot(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanReboot", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_halt(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHalt", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_suspend(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanSuspend", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_hibernate(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHibernate", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_hybrid_sleep(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanHybridSleep", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanSuspendThenHibernate", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "ScheduleShutdown", (arg0, arg1, ))
    }

    fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CancelScheduledShutdown", ())
            .and_then(|r: (bool,)| Ok(r.0))
    }

    fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "Inhibit", (arg0, arg1, arg2, arg3, ))
            .and_then(|r: (arg::OwnedFd,)| Ok(r.0))
    }

    fn can_reboot_parameter(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanRebootParameter", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_parameter(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SetRebootParameter", (arg0, ))
    }

    fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanRebootToFirmwareSetup", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SetRebootToFirmwareSetup", (arg0, ))
    }

    fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderMenu", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_boot_loader_menu(&self, arg0: u64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderMenu", (arg0, ))
    }

    fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderEntry", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_reboot_to_boot_loader_entry(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderEntry", (arg0, ))
    }

    fn get_enable_wall_messages(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "EnableWallMessages")
    }

    fn get_wall_message(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "WallMessage")
    }

    fn get_nauto_vts(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NAutoVTs")
    }

    fn get_kill_only_users(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillOnlyUsers")
    }

    fn get_kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillExcludeUsers")
    }

    fn get_kill_user_processes(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillUserProcesses")
    }

    fn get_reboot_parameter(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootParameter")
    }

    fn get_reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToFirmwareSetup")
    }

    fn get_reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToBootLoaderMenu")
    }

    fn get_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToBootLoaderEntry")
    }

    fn get_boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "BootLoaderEntries")
    }

    fn get_idle_hint(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleHint")
    }

    fn get_idle_since_hint(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHint")
    }

    fn get_idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHintMonotonic")
    }

    fn get_block_inhibited(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "BlockInhibited")
    }

    fn get_delay_inhibited(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "DelayInhibited")
    }

    fn get_inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitDelayMaxUSec")
    }

    fn get_user_stop_delay_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "UserStopDelayUSec")
    }

    fn get_handle_power_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandlePowerKey")
    }

    fn get_handle_suspend_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleSuspendKey")
    }

    fn get_handle_hibernate_key(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleHibernateKey")
    }

    fn get_handle_lid_switch(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitch")
    }

    fn get_handle_lid_switch_external_power(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitchExternalPower")
    }

    fn get_handle_lid_switch_docked(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitchDocked")
    }

    fn get_holdoff_timeout_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HoldoffTimeoutUSec")
    }

    fn get_idle_action(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleAction")
    }

    fn get_idle_action_usec(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleActionUSec")
    }

    fn get_preparing_for_shutdown(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForShutdown")
    }

    fn get_preparing_for_sleep(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForSleep")
    }

    fn get_scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "ScheduledShutdown")
    }

    fn get_docked(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "Docked")
    }

    fn get_lid_closed(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "LidClosed")
    }

    fn get_on_external_power(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "OnExternalPower")
    }

    fn get_remove_ipc(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RemoveIPC")
    }

    fn get_runtime_directory_size(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RuntimeDirectorySize")
    }

    fn get_inhibitors_max(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitorsMax")
    }

    fn get_ncurrent_inhibitors(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentInhibitors")
    }

    fn get_sessions_max(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "SessionsMax")
    }

    fn get_ncurrent_sessions(&self) -> Result<u64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentSessions")
    }
}

#[derive(Debug)]
pub struct ManagerSessionNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerSessionNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerSessionNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerSessionNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerSessionNew {
    const NAME: &'static str = "SessionNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerSessionRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerSessionRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerSessionRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerSessionRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerSessionRemoved {
    const NAME: &'static str = "SessionRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerUserNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerUserNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerUserNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerUserNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerUserNew {
    const NAME: &'static str = "UserNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerUserRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerUserRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerUserRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerUserRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerUserRemoved {
    const NAME: &'static str = "UserRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerSeatNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerSeatNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerSeatNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerSeatNew {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerSeatNew {
    const NAME: &'static str = "SeatNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerSeatRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for ManagerSeatRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
}

impl arg::ReadAll for ManagerSeatRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerSeatRemoved {
            arg0: i.read()?,
            arg1: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerSeatRemoved {
    const NAME: &'static str = "SeatRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerPrepareForShutdown {
    pub arg0: bool,
}

impl arg::AppendAll for ManagerPrepareForShutdown {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
}

impl arg::ReadAll for ManagerPrepareForShutdown {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerPrepareForShutdown {
            arg0: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerPrepareForShutdown {
    const NAME: &'static str = "PrepareForShutdown";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct ManagerPrepareForSleep {
    pub arg0: bool,
}

impl arg::AppendAll for ManagerPrepareForSleep {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
}

impl arg::ReadAll for ManagerPrepareForSleep {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ManagerPrepareForSleep {
            arg0: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ManagerPrepareForSleep {
    const NAME: &'static str = "PrepareForSleep";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}
